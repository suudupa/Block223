class Block223 {
   1 <@>- * PlayedGame playedGames;
   1 <@>- * HallOfFameEntry entries;
   
   public PlayedGame findPlayableGame(int id) {
	  for (PlayedGame g : playedGames) {
		  if (g.getId() == id) {
			  return g;
		  }
	  }
	  return null;
  }
}

class Game {
   Boolean published = false;
   1 -> 0..1 HallOfFameEntry mostRecentEntry;
}

class PlayedGame {
   const Integer INITIAL_WAIT_TIME = 30; // at design time, the initial wait time may be adjusted as seen fit
   autounique id;
   const Integer NR_LIVES = 3;
   Integer score = 0;
   Integer lives = NR_LIVES;
   Integer currentLevel = 1;
   Double waitTime = INITIAL_WAIT_TIME;
   * -- 0..1 Player player; // an admin may test the game; a game is played in test mode if player == null
   playername; // added here so that it only needs to be determined once
   
   // the PlayedBall and PlayedPaddle are not in a separate class to avoid the bug in Umple that occurred for the second constructor of Game

   // no direct link to Ball, because the ball can be found by navigating to Game and then Ball
   const Integer BALL_INITIAL_X = Game.PLAY_AREA_SIDE / 2;
   const Integer BALL_INITIAL_Y = Game.PLAY_AREA_SIDE / 2;
   // 0/0 is the top left corner of the play area, i.e., a directionX/Y of 0/1 moves the ball down in a straight line
   defaulted Double ballDirectionX = getGame().getBall().getMinBallSpeedX();
   defaulted Double ballDirectionY = getGame().getBall().getMinBallSpeedY();
   // the position of the ball is at the center of the ball
   defaulted Double currentBallX = BALL_INITIAL_X;
   defaulted Double currentBallY = BALL_INITIAL_Y;

   const Integer PADDLE_MOVE_RIGHT = 5; // pixels moved when right arrow key is pressed
   const Integer PADDLE_MOVE_LEFT = -5; // pixels moved when left arrow key is pressed
   Double currentPaddleLength = getGame().getPaddle().getMaxPaddleLength();
   // the position of the paddle is at its top left corner
   defaulted Double currentPaddleX = (Game.PLAY_AREA_SIDE - currentPaddleLength) / 2;
   immutable Double currentPaddleY = Game.PLAY_AREA_SIDE - Paddle.VERTICAL_DISTANCE - Paddle.PADDLE_WIDTH;

   * -- 1 Game game;
   1 <@>- * PlayedBlockAssignment blocks;
   0..1 -> 0..1 BouncePoint bounce;
   
   before constructor {
      boolean didAddGameResult = setGame(aGame);
      if (!didAddGameResult)
      {
         throw new RuntimeException("Unable to create playedGame due to game");
      }
   }
}

class PlayedBlockAssignment {
   // the associated block is either (a) the same as the one of the corresponding BlockAssignent or (b) randomly chosen
   * -- 1 Block block;
   // the position of a block is at its top left corner
   Integer x;
   Integer y;
}

class HallOfFameEntry {
   Integer score;
   playername; // added here so that it only needs to be determined once
   * -- 1 Player player;
   // the sorted keyword keeps the list of entries in the game automatically sorted by the score
   * sorted {score} -- 1 Game game;
}

// this class needs to be specified but the use of it is optional; it is also not added to the persistence file
// you may implement bounce behavior differently
class BouncePoint {
   Double x;
   Double y;
   enum BounceDirection { FLIP_X, FLIP_Y, FLIP_BOTH }
   BounceDirection direction;
   0..1 -> 0..1 PlayedBlockAssignment hitBlock;
}